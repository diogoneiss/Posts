## Nomes de teste descrevem funcionalidades

Como não vamos invocar as funções de teste, elas podem ter nomes grndes para serem bem descritivas quanto ao que é testado, sendo auto-documentáveis

## Tests smells

## Condicionais

Podem ter casos que o teste não execute o if, o que não é desejado, já que deve testar sempre um comportamento determinístico e condicionais tornam o teste imprevisível, ele pode não chegar na asserção correta e não testar nada

Eles podem existir no caso de restrição de ambiente, para verificar qual ambiente o teste está rodando, como no caso de Windows ou Mac.

## Teste obscuro

Teste complexo que dificulta o entendimento do que está sendo testado, pouco auto documentável

## Testes copiados

Toleráveis para asserção de funcionamento adequado em edge cases, porém podem ser substituidos por testes parametrizados em vários casos

## Fixture genérica

Ocorre quando uma fixture é criada excesivamene genérica, com atributos não usados pelos métodos de teste e poluindo o ambiente.

Outro problema é a performance, já que o setUp seria chamado antes de todos os métodos de teste. Seria melhor refatorar para vários setUps estáticos diferentes, cada um no escopo de classe, de modo que fossem chamados uma única vez e os testes que precisam das respectivas variáveis estariam na classe que testa.

Um exemplo disso é uma feature complexa que tem múltiplos atributos gerados, com um setUp estático de classe criando a fixture e cada teste verificando se a variável para tal comportamento está como esperado.

## Cobertura

* Cobertura de linhas: Linhas executadas nos testes pelo menos uma vez
* Cobertura de branches: Linhas e branches cobertas, como o caso de condicionais raros. O condicional só entrará na métrica de cobertura se todos os casos acontecerem

Cobertura de branches é sempre mais difícil, já que cobre condicionais.

Cobertura abaixo de 50% é preucupante, com o desejável acima de 78%. A cobertura depende bastante da linguagem, com Python, por exemplo, sendo mais fácil de atingir cobertura alta que linguagens como C++

Sabemos que baixa cobertura implica em ausência de testes, porém alta cobertura não significa testes bons, significa que testes existem, o que pode ser feito facilmente com testes complexos, asserções vazias ou mesmo testes ruins. Cobertura apenas significa que as linhas foram rodadas. Features que mudam frequentemente devem ter cobertura mais alta, garantindo que testes capturem potenciais introduções de bugs

## Design for testability

Códigos que são fáceis de ser testados implicam em alta coesão e baixo acoplamento, melhorando o projeto de sistema

Para refatorar sistemas legado, podemos usar de regra geral testar o mais externo e refatorar o mais interno, usando testes de aprovação, fazendo refatorações pontuais para deixá-lo mais testável.

O jeito mais compreensível é quebrar métodos complexos em pequenos métodos testáveis, extraindo esses métodos e testando-os

## Test driven development

Escrever teste, falhar, escrever mínima implementação viável, passar teste

Refatorar implementação até o projeto estar satisfatório

Começaremos com um teste falho, já que nenhum dos métodos existe, criaremos as implementações e o retorno trivial para o teste passar, refatorando até a implementação estar satisfatória

Sua vantagem é que você recebe o teste de graça, pensando sobre o que é necessário para a implementação da feature e o que ela envolverá, os métodos e seus parâmetros, tipos de retorno, etcs, deixado ele altamente coeso. Outro efeito é facilitar a depuração, já que temos um critério de aceitação do que é esperado e o que foi retornado pelo sistema sob teste.

Se necessário podemos refatorar o código do teste também, adequando-o ao comportamento sob teste
